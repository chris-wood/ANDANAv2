%The traditional idea of sessions does not have a direct analogue in the context of NDN. User emphasis is shifted from hosts (content producers) to the data they provide. As a result, it is more useful to associate sessions with content, or namespaces of content, rather than a single host. Furthermore, sessions are only meaningful if they provide the most up-to-date version of content. Consider a simple e-commerce website where sessions are used to persist the contents of a user's shopping cart. After a user adds an item to their cart the most recent version of the cart will likely be returned to them to see. In doing so, the contents of this cart will be stored in all network router content stores $C_1,\dots,C_n$ between the user and the e-commerce provider. Now say the user changes locations such that the new path from their location to the provider does not flow through any of the previous $n$ routers. The user again adds another item to their shopping cart and the contents are returned, being cached at the new routers along the way. Finally, the same user returns to their original location and requests the contents of its shopping cart. If any of the $n$ content stores $C_1,\dots,C_n$ still contain this (now outdated) information, stale shopping cart contents will be returned to the user. 
%
%While an extreme example, it illustrates how session content should always be served from the original producer. Thus, any meaningful solution to support sessions should do so such that the content will not be served from in-network storage. Of course, this is not a firm requirement. In the previous example, the user could simply re-request the contents of their shopping cart and utilize the exclude filter to ensure that the same cached content is not returned. However, if all $C_1,\dots,C_n$ routers still contain the content, then it would require $n + 1$ interests to get the contents of the shopping cart, which is quite a waste of resources.
%
%In this note, I describe a solution to implementing meaningful content-based sessions in NDN. It relies on the following cryptographic algorithms and primitives. Note that identity-based primitives are chosen because they are a more natural fit for NDN, where identities can be simple (and smaller) strings and thus readable name components. 
%
%\begin{itemize}
%	\item Rabin signature scheme: Fast signature verification to help mitigate ``session flooding'' attacks (i.e. interests with invalid session states that cause the producer to waste cycles performing signature verification).
%	\begin{itemize}
%		\item $\mathsf{RabinKeyGen}(k)$ - Generate $p,q,n,b$, where $n = pq$ and $p,q$ are large safe primes.
%		\item $\mathsf{RabinSign}((p,q), M)$ - Sign the message $M$ with the private key $(p,q)$.
%		\item $\mathsf{RabinVerify}((n,b), \sigma)$ - Verify the signature $\sigma$ with the public key $(n,b)$.
%		\item $(p,q)$ - Rabin scheme private key.
%		\item $(n,b)$ - Rabin scheme public key.
%	\end{itemize}
%	\item Diffie-Hellman (DH) key exchange: Generate a random symmetric key for AES.
%	\begin{itemize}
%		\item $g$ - The DH group generator of at least 1024 bits.
%		\item $\alpha$ and $\beta$ - Private DH exponents generated by the parties (consumer and producer) participating in the session formation.
%	\end{itemize}
%	\item AES-128: Encrypt the session identifier in transit between the consumer and producer to prevent hijacking. 
%	\item Identity-based (IB) encryption: Enable the preliminary exchange of information needed to set up session support (i.e. DH session and AES key, Rabin signature parameters, etc).
%	\begin{itemize}
%		\item $\mathsf{IBEncrypt}(ID, M)$ - Encrypt the message $M$ under the identity $ID$.
%		\item $\mathsf{IBDecrypt}(ID_{sk}, M')$ - Decrypt the message $M'$ using the private key $ID_{sk}$ associated with the identity $ID$.
%	\end{itemize}
%	\item Identity-based signature scheme: Enable the preliminary exchange of information needed to set up session support (i.e. DH session and AES key, Rabin signature parameters, etc).
%	\begin{itemize}
%		\item $\mathsf{IBSign}(\mathsf{ID}, M)$ - Sign the message $M$ using the identity $ID$.
%		\item $\mathsf{IBVerify}(\mathsf{ID_{sk}}, \sigma)$ - Verify the signature $\sigma$ using the private key $ID_{sk}$ associated with the identity $ID$.
%	\end{itemize}
%\end{itemize}
%
%The solution security parameters are $k$ (the bit length of the Rabin modulus), $l$ (Diffie-Hellman group size in bits), and $m$ (the IB encryption security parameter). These parameters will be used where needed in the solution description. Furthermore, it is assumed that public parameters for each of the above schemes (i.e. the hash function used for the Rabin scheme) are publicly known and fixed. I have not yet reconciled when the setup procedure for the IB encryption scheme will be run, as this is responsible for instantiating the parameters of the group based on $m$ (i.e. the pairing groups and hash functions). Finally, certain functions used in this solution, such as $\mathsf{RabinKeyGen}(k)$, are modifications of the original algorithms that make the presentation easier to follow. Their purpose should be clear from context.

% %%% PROTOCOL DESCRIPTION
% \begin{figure}[ht!]
% \begin{center}
% \caption{Consumer/producer interaction to create and maintain sessions in NDN.}
% % \begin{mdframed}
% \begin{tikzpicture}[thick,scale=0.75, every node/.style={scale=0.75}]
% \matrix (m)[matrix of nodes, column  sep=2cm,row  sep=3mm, nodes={draw=none, anchor=center,text depth=0pt} ]{
% \node [] {Consumer}; & \node [] {}; & \node [] {Producer}; \\
% \node [] {$p,q,b \gets \mathsf{RabinKeyGen(k)}, n = pq$}; & \node [] {}; & \node [] {};\\
% \node [] {$g,\alpha \gets \mathsf{DHSetup}(l)$}; &\node [] {}; & \node [] {};\\
% \node [] {$\mathsf{D} := \mathsf{IBEncrypt}(\mathsf{P_{ID}}, n || b || g || g^\alpha || sk)$}; & \node [] {}; & \node [] {};\\
% \node [] {$\mathsf{I} := $ /random/interest}; & \node [] {};& \node [] {};\\
% \node [] {$\mathsf{S_s} := (\mathsf{D}, \mathsf{C_{ID}}, \mathsf{IBSign}(C_{sk}, \mathsf{D} || \mathsf{C_{ID}} || \mathsf{I}))$}; & \node [] {};& \node [] {};\\
% %\node [] {};  & \node [] {Send $\mathsf{I}/\mathsf{S_s}$}; & \node [] {};\\
% \node [] {};& \node [] {};& \node [] {}; \\
% \node [] {}; & \node [] {}; & \node [] {$\mathsf{Verify}(\mathsf{C_{ID}}, \mathsf{S_s}[3])$}; \\
% \node [] {};& \node [] {};& \node [] {$n || b || g || g^\alpha := \mathsf{IBDecrypt}(\mathsf{P_{sk}}, \mathsf{S_s}[1])$}; \\
% \node [] {};& \node [] {};& \node [] {$\beta \gets \mathsf{DHGen}(l)$}; \\ 
% \node [] {};& \node [] {};& \node [] {$\mathsf{s} := \mathsf{GenerateSessionID}()$}; \\
% \node [] {};& \node [] {};& \node [] {$sk := H(g^{\alpha\beta}), s' := \mathsf{AESEncrypt}(sk, s)$}; \\
% \node [] {}; & \node [] {}; & \node [] {};\\
% \node [] {$sk := H(g^{\alpha\beta}), s := \mathsf{AESDecrypt}(sk, s')$}; & \node [] {};& \node [] {};\\
% \node [] {}; & \node [] {\vdots}; & \node [] {};\\
% \node [] {$\mathsf{I} := $ /random/interest}; & \node [] {};& \node [] {};\\
% \node [] {$r \gets \mathsf{RandomNonce}(k)$}; & \node [] {};& \node [] {};\\
% \node [] {$s' \gets AESEncrypt(sk, s)$}; & \node [] {}; & \node [] {}; \\
% \node [] {$\mathsf{S_t} := (\mathsf{C_{ID}}, s', \mathsf{RabinSign}((p, q), s || \mathsf{I} || \mathsf{C_{ID}} || r)$}; & \node [] {};&  \node [] {};\\
% \node [] {}; & \node [] {}; & \node [] {};\\
% \node [] {};& \node [] {};& \node [] {$\mathsf{RabinVerify}((n,b), \mathsf{S_t}[3])$}; \\
% \node [] {};& \node [] {};& \node [] {$s := \mathsf{AESDecrypt}(sk, \mathsf{S_t}[2])$}; \\
% \node [] {};& \node [] {};& \node [] {Generate content $C$ for this session}; \\
% \node [] {};& \node [] {}; & \node [] {};\\
% };

% \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-1.south east)--(m-1-1.south west);
% \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-3.south east)--(m-1-3.south west);

% \path [>=latex,->] (m-7-1.south east) edge node [above] {Send $\mathsf{I}/\mathsf{S_s}$} (m-7-3.south west);
% \path [>=latex,<-] (m-13-1.south east) edge node [above] {Send $s', g^\beta$} (m-13-3.south west);
% \path [>=latex,->] (m-20-1.south east) edge node [above] {Send $\mathsf{I}/\mathsf{S_t}$} (m-20-3.south west);
% \path [>=latex,<-] (m-24-1.south east) edge node [above] {Send $C$} (m-24-3.south west);


% \end{tikzpicture}
% \end{center}
% % \end{mdframed}
% \end{figure}